/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.32                          *
*        Compiled Oct  8 2015, 11:59:02                              *
*        (c) 2015 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

#include "main.h"


#define ID_WINDOW_0 (GUI_ID_USER + 0x02)
#define ID_HEADER_0 (GUI_ID_USER + 0x07)
#define ID_TEXT_HEADER (GUI_ID_USER + 0x08)
#define ID_BUTTON_CANCEL (GUI_ID_USER + 0x11)
#define ID_BUTTON_SAVE (GUI_ID_USER + 0x15)
#define ID_TEXT_TITLE (GUI_ID_USER + 0x25)
#define ID_BUTTON_PERIOD (GUI_ID_USER + 0x26)
#define ID_BUTTON_START (GUI_ID_USER + 0x27)
#define ID_BUTTON_STOP (GUI_ID_USER + 0x28)
#define ID_BUTTON_TEMPURATURE (GUI_ID_USER + 0x29)
#define ID_TEXT_WAKE (GUI_ID_USER + 0x2A)
#define ID_TEXT_START_TIME (GUI_ID_USER + 0x2B)
#define ID_TEXT_STOP_TIME (GUI_ID_USER + 0x2C)
#define ID_TEXT_TEMP_VAR (GUI_ID_USER + 0x2D)
#define ID_BUTTON_UP (GUI_ID_USER + 0x2E)
#define ID_BUTTON_DN (GUI_ID_USER + 0x2F)

/*********************************************************************
*
*       _aDialogCreate
*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] =
{
    { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 480, 272, 0, 0x0, 0 },
    { HEADER_CreateIndirect, "Header", ID_HEADER_0, 0, 0, 480, 50, 0, 0x0, 0 },
    { TEXT_CreateIndirect, "EDIT SCHEDULE:", ID_TEXT_HEADER, 0, 0, 252, 50, 0, 0x64, 0 },
    { BUTTON_CreateIndirect, "CANCEL", ID_BUTTON_CANCEL, 20, 230, 80, 28, 0, 0x0, 0 },
    { BUTTON_CreateIndirect, "SAVE", ID_BUTTON_SAVE, 378, 230, 80, 28, 0, 0x0, 0 },
    { TEXT_CreateIndirect, "", ID_TEXT_TITLE, 280, 0, 189, 50, 0, 0x64, 0 },
    { BUTTON_CreateIndirect, "PERIOD", ID_BUTTON_PERIOD, 25, 90, 90, 26, 0, 0x0, 0 },
    { BUTTON_CreateIndirect, "START", ID_BUTTON_START, 135, 90, 90, 26, 0, 0x0, 0 },
    { BUTTON_CreateIndirect, "STOP", ID_BUTTON_STOP, 245, 90, 90, 26, 0, 0x0, 0 },
    { BUTTON_CreateIndirect, "Button", ID_BUTTON_TEMPURATURE, 355, 90, 90, 26, 0, 0x0, 0 },
    { TEXT_CreateIndirect, "WAKE", ID_TEXT_WAKE, 31, 60, 83, 23, 0, 0x64, 0 },
    { TEXT_CreateIndirect, "Text", ID_TEXT_START_TIME, 144, 60, 80, 23, 0, 0x64, 0 },
    { TEXT_CreateIndirect, "Text", ID_TEXT_STOP_TIME, 251, 62, 81, 22, 0, 0x64, 0 },
    { TEXT_CreateIndirect, "TEMP", ID_TEXT_TEMP_VAR, 363, 63, 80, 20, 0, 0x64, 0 },
    { BUTTON_CreateIndirect, "", ID_BUTTON_UP, 45, 120, 48, 48, 0, 0x0, 0 },
    { BUTTON_CreateIndirect, "", ID_BUTTON_DN, 45, 168, 48, 48, 0, 0x0, 0 },
};

static int period_on, start_on, stop_on, temp_on;

static void periodButton_cb(WM_MESSAGE * pMsg)
{
    scheduleButton(pMsg, "PERIOD", period_on);
}

static void start_button_on(WM_MESSAGE * pMsg)
{
    scheduleButton(pMsg, "START", start_on);
}

static void stopButton_cb(WM_MESSAGE * pMsg)
{
    scheduleButton(pMsg, "STOP", stop_on);
}

static void tempButton_cb(WM_MESSAGE * pMsg)
{
    scheduleButton(pMsg, "TEMP", temp_on);
}

static WM_HWIN periodButton, startButton, stopButton, tempButton;
static WM_HWIN wake_text, start_text, stop_text, temp_text;
static WM_HWIN upButton, dnButton, weekdayButton;
static int selected_button, tempurature, period;
static struct periods_s periods[4];
static struct periods_s getPeriod(char * p);
static struct days_s selectedDay;

static char *periods_text[] = {"wake","leave","return","sleep"};
static char edit_title[20];

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg)
{
    WM_HWIN hItem;
    int     NCode;
    int     Id;
    char buf[10];

    switch (pMsg->MsgId)
    {
    case WM_INIT_DIALOG:
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_HEADER);
        TEXT_SetFont(hItem, GUI_FONT_32_1);
        TEXT_SetTextAlign(hItem, GUI_TA_RIGHT | GUI_TA_VCENTER);
        TEXT_SetTextColor(hItem, GUI_MAKE_COLOR(0x00FFFFFF));
        //
        hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_TITLE);
        TEXT_SetTextAlign(hItem, GUI_TA_LEFT | GUI_TA_VCENTER);
        TEXT_SetFont(hItem, GUI_FONT_32B_1);
        TEXT_SetTextColor(hItem, GUI_MAKE_COLOR(0x00FFFFFF));
        TEXT_SetText(hItem, toup(edit_title));

        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_CANCEL);
        WM_SetCallback(hItem, buttonOn16_cb);
        //
        hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_SAVE);
        WM_SetCallback(hItem, buttonOn16_cb);
        //
        periodButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_PERIOD);
        WM_SetCallback(periodButton, periodButton_cb);
        //
        startButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_START);
        WM_SetCallback(startButton, start_button_on);
        //
        stopButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_STOP);
        WM_SetCallback(stopButton, stopButton_cb);
        //
        tempButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_TEMPURATURE);
        WM_SetCallback(tempButton, tempButton_cb);
        //
        wake_text = WM_GetDialogItem(pMsg->hWin, ID_TEXT_WAKE);
        TEXT_SetFont(wake_text, GUI_FONT_20B_1);
        TEXT_SetTextAlign(wake_text, GUI_TA_HCENTER | GUI_TA_VCENTER);
        TEXT_SetTextColor(wake_text, GUI_MAKE_COLOR(0x00808080));
        TEXT_SetText(wake_text, toup(getPeriod(periods_text[0]).label));
        //
        start_text = WM_GetDialogItem(pMsg->hWin, ID_TEXT_START_TIME);
        TEXT_SetTextAlign(start_text, GUI_TA_HCENTER | GUI_TA_VCENTER);
        TEXT_SetFont(start_text, GUI_FONT_20B_1);
        TEXT_SetText(start_text, getPeriod(periods_text[0]).startTime);
        TEXT_SetTextColor(start_text, GUI_MAKE_COLOR(0x00808080));
        //
        stop_text = WM_GetDialogItem(pMsg->hWin, ID_TEXT_STOP_TIME);
        TEXT_SetFont(stop_text, GUI_FONT_20B_1);
        TEXT_SetTextAlign(stop_text, GUI_TA_HCENTER | GUI_TA_VCENTER);
        TEXT_SetText(stop_text,  getPeriod(periods_text[0]).stopTime);
        TEXT_SetTextColor(stop_text, GUI_MAKE_COLOR(0x00808080));
        //
        temp_text = WM_GetDialogItem(pMsg->hWin, ID_TEXT_TEMP_VAR);
        TEXT_SetFont(temp_text, GUI_FONT_20B_1);
        TEXT_SetTextAlign(temp_text, GUI_TA_HCENTER | GUI_TA_VCENTER);
        sprintf(buf, "%d",  getPeriod(periods_text[0]).tempurature);
        TEXT_SetText(temp_text, buf);
        TEXT_SetTextColor(temp_text, GUI_MAKE_COLOR(0x00808080));
        //
        upButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_UP);
        WM_SetCallback(upButton, big_up_button);
        //
        dnButton = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_DN);
        WM_SetCallback(dnButton, big_dn_button);
        break;
    case WM_NOTIFY_PARENT:
        Id    = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;
        char buf[10], *am;
        int hh, mm;

        switch(Id)
        {
        case ID_BUTTON_CANCEL:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                state = 13;
                break;
            }
            break;
        case ID_BUTTON_SAVE:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                state = 13;
                break;
            }
            break;
        case ID_BUTTON_PERIOD:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                selected_button = 0;
                period_on = 1;
                start_on = 0;
                stop_on = 0;
                temp_on = 0;

                WM_InvalidateWindow(periodButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(stopButton);
                WM_InvalidateWindow(tempButton);
                WM_MoveTo(upButton, 45,120);
                WM_MoveTo(dnButton, 45,168);
                break;
            }
            break;
        case ID_BUTTON_START:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                selected_button = 1;
                period_on = 0;
                start_on = 1;
                stop_on = 0;
                temp_on = 0;

                WM_InvalidateWindow(periodButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(stopButton);
                WM_InvalidateWindow(tempButton);
                WM_MoveTo(upButton, 155,120);
                WM_MoveTo(dnButton, 155,168);
                break;
            }
            break;
        case ID_BUTTON_STOP:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                selected_button = 2;
                period_on = 0;
                start_on = 0;
                stop_on = 1;
                temp_on = 0;

                WM_InvalidateWindow(periodButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(stopButton);
                WM_InvalidateWindow(tempButton);
                WM_MoveTo(upButton, 265,120);
                WM_MoveTo(dnButton, 265,168);
                break;
            }
            break;
        case ID_BUTTON_TEMPURATURE:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                period_on = 0;
                start_on = 0;
                stop_on = 0;
                temp_on = 1;
                selected_button = 3;

                WM_InvalidateWindow(periodButton);
                WM_InvalidateWindow(startButton);
                WM_InvalidateWindow(stopButton);
                WM_InvalidateWindow(tempButton);
                WM_MoveTo(upButton, 375,120);
                WM_MoveTo(dnButton, 375,168);
                break;
            }
            break;
        case ID_BUTTON_UP:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                switch(selected_button)
                {
                case 0:
                    period++;
                    if (period == 4) period = 0;
                    TEXT_SetText(wake_text, toup(getPeriod(periods_text[period]).label));
                    TEXT_SetText(start_text, getPeriod(periods_text[period]).startTime);
                    TEXT_SetText(stop_text, getPeriod(periods_text[period]).stopTime);
                    itoa(getPeriod(periods_text[period]).tempurature, buf, 10);
                    TEXT_SetText(temp_text, buf);
                    break;
                case 1:
                    TEXT_GetText(start_text, buf, 10);
                    TEXT_SetText(start_text, updateTime(buf,1));
                    break;
                case 2:
                    TEXT_GetText(stop_text, buf, 10);
                    TEXT_SetText(stop_text, updateTime(buf, 1));
                    break;
                case 3:
                    periods[selected_button].tempurature++;
                    if (periods[selected_button].tempurature == 110) periods[selected_button].tempurature = 110;
                    itoa(periods[selected_button].tempurature, buf, 10);
                    TEXT_SetText(temp_text, buf);
                    break;
                }
                break;
            }
            break;
        case ID_BUTTON_DN:
            switch(NCode)
            {
            case WM_NOTIFICATION_CLICKED:
                switch(selected_button)
                {
                case 0:
                    period--;
                    if (period == -1) period = 3;
                    TEXT_SetText(wake_text, toup(periods[period].label));
                    TEXT_SetText(start_text, periods[period].startTime);
                    TEXT_SetText(stop_text, periods[period].stopTime);
                    itoa(periods[period].tempurature, buf, 10);
                    TEXT_SetText(temp_text, buf);
                    break;
                case 1:
                    TEXT_GetText(start_text, buf, 10);
                    TEXT_SetText(start_text, updateTime(buf, -1));
                    break;
                case 2:
                    TEXT_GetText(stop_text, buf, 10);
                    TEXT_SetText(stop_text, updateTime(buf, -1));
                    break;
                case 3:
                    periods[selected_button].tempurature--;
                    if (periods[selected_button].tempurature == 64) periods[selected_button].tempurature = 65;
                    itoa(periods[selected_button].tempurature, buf, 10);
                    TEXT_SetText(temp_text, buf);
                    break;
                }
                break;
            }
        }
        break;
    default:
        WM_DefaultProc(pMsg);
        break;
    }
}

static struct days_s getPeriods(char * p)
{
    struct days_s days;
    int i,k,j;

    int sz1 = sizeof(schedules) / sizeof(schedules[0]);

    for (i=0; i<sz1; i++)
    {
        for (k=0; k<schedules[i].day_count; k++)
        {
            if (strcmp(schedules[i].days[k].label,p) == 0)
            {
                days = schedules[i].days[k];
                for (j=0; j<4; j++)
                {
                    periods[j] = schedules[i].days[k].periods[j];
                }
            }
        }
    }
    return days;
}

static struct periods_s getPeriod(char * p)
{
    int sz1 = sizeof(periods) / sizeof(periods[0]);
    int i;
    for (i=0; i<sz1; i++)
    {
        if (strcmp(selectedDay.periods[i].label, p) == 0)
        {
            return selectedDay.periods[i];
            break;
        }
    }

}

/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateEditSchedule(char *per);
WM_HWIN CreateEditSchedule(char *per)
{
    WM_HWIN hWin;

    strcpy(edit_title, per);
    selectedDay = getPeriods(per);
    period = 0;

    period_on = 1;

    hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
    return hWin;
}

/*************************** End of file ****************************/
